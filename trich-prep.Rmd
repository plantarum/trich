# Setup
## Files
The following files are necessary to compile this document. Additionally,
the first time you run it you will need internet access for the script to
download the country maps for USA and Canada.

```
./trich.Rmd 
./trich-prep.Rmd
./data/survey-pops.csv
./data/ssr_raw.csv
./data/trich_soil.csv
./data/trich-gbif.csv
./data/background_points.csv
./data/eval.opt.2020-06-24.Rda
./data/maps/greatlakes.shp
./data/maps/greatlakes.shx
./data/maps/greatlakes.cpg
./data/maps/greatlakes.prj
./data/maps/greatlakes.dbf
./data/maps/greatlakes.qpj
./data/maps/envClean_ai.tif
./data/maps/envClean_bio_02.tif
./data/maps/envClean_bio_06.tif
./data/maps/envClean_bio_13.tif
./data/maps/envClean_srtm_Rugged.tif
```

## R libraries
**WARNING** big changes are coming for the `raster` package, and other
packages used for spatial analysi in R. This may cause problems running the
code below after 2023 or so, when the current versions are deprecated. You
may need to find archived versions of key packages after that, or convert
the code to whatever new packages are in use at that point (i.e.,
`terra`?). 

```{R libraries}
library(adegenet)
library(adespatial)
library(sp) # coordinates
library(spdep)  # nbdists
library(raster) # crs
library(poppr) # mlg.vector
library(spThin) # thin
library(ENMeval)
library(dismo)
library(vegan)
library(hierfstat)
library(PopGenReport)
library(dplyr)
library(ENMTools)
library(pegas) #hw.test
library(scales)
library(viridis)
library(ggplot2)
library(tidyr)
library(adehabitatHR)
library(dendextend)
library(maptree)
```
# Analysis
## Population Data
```{R loading samples}
samples <- read.csv("data/survey-pops.csv")
samples$size <- factor(samples$size,
                       levels = c("Very small", "Small",
                                  "Medium", "Large"))  
row.names(samples) <- samples$population

soil <- read.table("data/trich_soil.csv", header = TRUE,
                  row.names = 1) 

samples[row.names(soil), colnames(soil)]  <-  soil

colnames(samples)[3:4] <- c("Latitude", "Longitude")
coordinates(samples) <- ~Longitude+Latitude
crs(samples) <- CRS("+proj=longlat +datum=WGS84")

total = data.frame(population = "total")

geogD <- pointDistance(samples)
rownames(geogD) <- samples$population
colnames(geogD) <- samples$population
```

## Distribution Data
### Records
```{R gbif}
gbif <- read.table("data/trich-gbif.csv")
coordinates(gbif) <- ~X+Y

gbifthin <-
  thin(data.frame(LAT = coordinates(gbif)[, "Y"],
                  LONG = coordinates(gbif)[, "X"],
                  SPEC = rep("tplan", summary(gbif)$npoints)),
       thin.par = 10, reps = 1, write.files = FALSE,
       locs.thinned.list.return = TRUE)
gbifthin <- gbifthin[[1]]

## distance between sampled points and gbif records:
pd <- pointDistance(samples, gbifthin, lonlat = TRUE)

dupSites <- unlist(apply(pd, 1, function(x) which(x < 10000)))

gbifthin <- gbifthin[-dupSites, ]
## join GBIF and sampled pops:

gbifthin$population <- NA
gbifthin <- rbind(as.data.frame(gbifthin),
                 as.data.frame(samples)[, c("Longitude",
                                            "Latitude",
                                            "population")])
coordinates(gbifthin) <- ~Longitude+Latitude
crs(gbifthin) <- CRS("+proj=longlat +datum=WGS84")
```

### Isolation Index
NB: isolation is my ad hoc isolation measure, kernel is the one we used in
the paper, based on the Utilization Distribution measure.

```{R isolation-prep}
isolation <- function(x, nb = 5){
  tmp  <- pointDistance(x, lonlat = TRUE)
  tmp <- as.matrix(as.dist(tmp))
  diag(tmp) <- NA
  tmp  <- apply(tmp, 1, function(x) mean(sort(x)[1:nb]))
  return(tmp)
}

gbifthin$isolation <- isolation(gbifthin, nb = 5)
tmpKernel <- kernelUD(gbifthin, h = "LSCV", grid = 1000)
kernelRaster <- raster(tmpKernel)
gbifthin$kernel <- raster::extract(kernelRaster, gbifthin) 
samples$kernel <- raster::extract(kernelRaster, samples)
samples$isolation  <- gbifthin@data[row.names(samples),
                                   "isolation"]
```

### Marginality Index
I didn't end up using this in the Botany paper.

```{R marginality}
gbifthin$marginality <- 
  mahalanobis(coordinates(gbifthin),
              colMeans(coordinates(gbifthin)),
              var(coordinates(gbifthin)))
samples$marginality <- 
  mahalanobis(coordinates(samples),
              colMeans(coordinates(gbifthin)),
              var(coordinates(gbifthin)))
```
### Soils

```{R soils}
soilCols <- c("Ca", "CEC", "OM", "P", "Mg", "K", "Mn", 
             "Zn", "pH")
soilData <- data.frame(samples)[, soilCols]
soilData <- soilData[complete.cases(soilData), ]
soilPCA <- prcomp(soilData, scale. = TRUE, center = TRUE) 
soilInd <- mahalanobis(predict(soilPCA),
                      colMeans(predict(soilPCA)),
                      var(predict(soilPCA)))
soilDist <- dist(scale(soilData))
soilClust <- hclust(soilDist, method = "average")
soilCophenetic <- cor(cophenetic(soilClust), soilDist)
soilKGS <- kgs(soilClust, soilDist) 
soilCut <- cutree(soilClust,
                 k =
                   as.numeric(names(soilKGS)[which.min(soilKGS)]))
soilData$group <- soilCut

```

## SSR
`trComp`

: genind object with all individuals with complete genotypes (i.e., no
  missing markers)

`trichGI4`

: genind object with all individuals with 8-11 markers scored (i.e., less
  than 4 missing markers)

`trichGI`

: genind object with all individuals scored

`tr97`

: genind object with one sample per unique MLG


### Loading Data
```{R ssr loading, echo=FALSE}
  ssr <- read.table("./data/ssr_raw.csv", header = TRUE, sep = "\t",
                    stringsAsFactors = FALSE)
  ssr$X <- NULL
  dupes <- duplicated(ssr$Sample)
  dupesRev <- duplicated(ssr$Sample, fromLast = TRUE)

  dupeNames <- ssr$Sample[dupes]
  ## check on duplicates, combine genotypes from the same sample. 
  for(i in dupeNames){
    tmp <- ssr[ssr$Sample == i, ]
    combine <- apply(tmp, 2, function(x)
      ifelse(x[1] == "", x[2], x[1]))
    ssr <- ssr[ssr$Sample != i, ]
    ssr <- rbind(ssr, combine)
  }

  row.names(ssr) <- ssr$Sample
  ssr$Sample <- NULL

  trichGI <- df2genind(ssr, sep = ",")
  pops <- substr(indNames(trichGI), start = 0, stop = 4)
  pops[grep("KY", pops)] <- "KY"
  pop(trichGI) <- pops

  trichGI@other <- list(xy = coordinates(samples)[pops, ])

  trComp <- complete.cases(tab(trichGI))
  trComp <- trichGI[trComp]

  tmp <- tab(trichGI)
  loci <- character()
  for(i in seq_along(alleles(trichGI))){
    tmp <- alleles(trichGI)
    loci[i] <- paste(names(tmp)[i], tmp[[i]][1], sep = ".")
  }

  lociTab <- tab(trichGI[, loci])
  indLoci <- apply(lociTab, 1, function(x) sum(is.na(x)))
  #table(indLoci)
  #cumsum(table(indLoci))
  ## accepting up to 3 missing loci gives us an extra 100 samples

  trichGI4 <- trichGI[indLoci < 4]

  samples[names(table(pop(trichGI4))), "n"]  <- table(pop(trichGI4))
  total$n <- sum(samples$n)
  
  trichGP4 <- genind2genpop(trichGI4)

  trichGP4@other <-list(xy =
                          coordinates(samples)[
                            rownames(tab(trichGP4)), ])  

  ## pulls one of each unique MLG:
  tr97 <- trComp[!duplicated(mlg.vector(trComp)), ]

  GP4sum <- summary(trichGP4)
  GI4sum <- summary(trichGI4)

  lociInd <- apply(lociTab, 2, function(x) sum(is.na(x)))
```


### Summaries
#### Samples, alleles, pairwise Fst
```{R ssr summaries}
NComp <- as.data.frame(table(pop(trComp)))
samples[ as.character(NComp$Var1), "NComp"]  <- NComp$Freq
total$NComp <- sum(samples$NComp)

# pairwise Fst
trichFst <- genet.dist(trichGI4, method = "Nei87")
fstmat <- as.matrix(trichFst)
diag(fstmat) <- NA
meanFst <- rowMeans(fstmat, na.rm = TRUE)
samples[colnames(t(meanFst)), "meanFst"]  <- meanFst

fst1 <- apply(fstmat, 2, function(x) any(x == 1, na.rm = TRUE))
##fstmat[fst1, fst1]

fst0 <- apply(fstmat, 2, function(x) any(x <= 0, na.rm = TRUE))
##fstmat[fst0, fst0]

## Private Alleles
## requires poppr
Ap <- rowSums(private_alleles(trichGI4, count.alleles = FALSE))
samples[colnames(t(Ap)), "Ap"]  <- Ap
## Allelic richness, PopGenReport
Ar <- allel.rich(trichGI4)$mean
samples[colnames(t(Ar)), "Ar"]  <- Ar 

```

#### MLG
`poppr` assigns ambgiuous mlg (due to missing loci) based on sort order,
which is arbitrary. The code below will correct this assignment, in the
sense that if an ambiguous genotype could match a complete MLG in its own
population, that is what we select, in preference over assigning it a MLG
that only occurs in a different population.

```{R mlg}
## incomplete genotypes: 
incomp <- apply(tab(trichGI4), 1, function(x) any(is.na(x)))

## discrete distance, which is 0 between matching complete mlg,
## and between a complete mlg and an incomplete mlg with no
## conflicting alleles:
giD <- diss.dist(trichGI4)

## mvc is a table of distances between incomplete and complete
## mlg: 
mvc <- as.matrix(giD)[incomp, !incomp]

## mlg as determined by poppr
mlgv <- mlg.vector(trichGI4)
names(mlgv) <- indNames(trichGI4)
## mlg assignments for complete genotypes, the ones we use as a
## reference (we know they are correct, to the limit of the
## available data)
mlgvComp <- mlgv[!incomp]

## iterate over each incomplete genotype, comparing it to the
## genotypes in its population. If it is assigned the same mlg,
## leave it. If it has a 0 distance from a complete mlg, assign
## it to that. Otherwise, leave it. 
for(i in indNames(trichGI4)[incomp]){
  sampPop <- pop(trichGI4[i])
  ## cat(paste(i, "\t", mlgv[i], "\t")) ## debugging
  if(mlgv[i] %in% mlgvComp[grep(sampPop, names(mlgvComp))]) {
    next # matches one of the complete MLG, ok!
  }

  testVec <- mvc[i, grep(sampPop, colnames(mvc)), drop = FALSE]

  matchP <- which(testVec == 0)
  if(length(matchP) > 0){ # it matches a MLG from another population
    matchMLG <- colnames(testVec)[matchP[1]]
    ## cat(mlgv[matchMLG], "\n") ## debugging
    mlgv[i] <- mlgv[matchMLG] # assign it to that MLG
  } else {
    ## debugging
    ## cat(mlgv[i], "\n") # it doesn't match any complete MLG
  }
}

mlg.tab <- table(pop(trichGI4), mlgv)

mlg.pop <- t(rowSums(mlg.tab > 0))
pop.mlg <- t(colSums(mlg.tab > 0))
samples[colnames(mlg.pop), "mlg"] <- t(mlg.pop)

## eMLG is the expected number of MLG for a common sample size of
## 10 individuals, determined via rarefaction

emlg.pop <- rarefy(mlg.tab, sample = 10)

samples[names(emlg.pop), "emlg"] <- emlg.pop
samples[samples$n < 10, "emlg"] <- NA

total$mlg <- ncol(mlg.tab)
total$emlg <- rarefy(colSums(mlg.tab), sample = 10)
```

#### Hierfstat: Ho, Hs, Fis, Fst

```{R popgen}
## hierfstat He, Ho: note that basic.stats automatically converts
## genind objects to hierfstat objects.

bs <- basic.stats(trichGI4)
## Ho, mean per-locus observed heterozygosity
Ho <- colMeans(bs$Ho)
samples[colnames(t(Ho)), "Ho"]  <- Ho

## Hs, mean per-locus gene diversity
Hs <- t(t(colMeans(bs$Hs)))
samples[colnames(t(Hs)), "Hs"]  <- Hs

## Fis, Fis=1-Ho/Hs, 
samples$Fis  <- 1 - samples$Ho/samples$Hs

## overall values:
total$Ho <- bs$overall["Ho"]
total$Hs <- bs$overall["Hs"]
total$Fis <- bs$overall["Fis"]
total$meanFst <- bs$overall["Fst"]
```

#### Hardy-Weinburg Equilibrium
```{R HWE}
trichGI4.hwt <- hw.test(trichGI4)
# trichGI4.hwt
```

## Mapping
Set up the North America map and save it for later (it takes a while to
compute).

This block won't be evaluated by default. You do need to evaluate it before
the subsequent code will run, but only once. So evaluate it by hand one
time (or set EVAL = TRUE to run it every time, if you don't mind waiting).

```{R prep-na-map, eval = FALSE}
us <- getData("GADM", country = "USA", level = 1, path = "./data/maps/")
canada <- getData("GADM", country = "CAN", level = 1, path = "./data/maps")

canlam <- CRS("+proj=lcc +lat_1=49 +lat_2=77 +lat_0=49 +lon_0=-95 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs")
ca.proj <- spTransform(canada, canlam)
us.proj <- spTransform(us, canlam)
na.proj <- bind(ca.proj, us.proj)

## convert to sf so we can use graticules:
na.proj <- st_as_sf(na.proj)
na.simp <- st_crop(na.proj, xmin = -40000, xmax = 2220000,
                  ymin = -3002435, ymax = 600000)
na.simp <- st_simplify(na.simp, dTolerance = 0.01)
save(na.simp , file = "data/na_simp.Rda")
```

```{R mapping data}
us <- getData("GADM", country = "USA", level = 1, path = "./data/maps/")
load("data/na_simp.Rda")

canlam <- CRS("+proj=lcc +lat_1=49 +lat_2=77 +lat_0=49 +lon_0=-95 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs")

greatlakes <- shapefile("data/maps/greatlakes.shp")
extent <- shapefile("data/maps/study_extent.shp")

gl.proj <- spTransform(greatlakes, canlam)
extent.proj <- spTransform(extent, canlam)
zm <- new("Extent", xmin = 40000,
         xmax = 2200000, ymin = -1502435,
         ymax = 20000) 

trich.proj <- spTransform(gbifthin, canlam)
```

## SDM
```{R sdm}
## environment layers already screened via usdm::vif
env <- stack(list.files("data/maps", ".tif",
                       full.names = TRUE))
names(env) <- gsub("envClean_", "", names(env))

background <- read.table("data/background_points.csv")
coordinates(background) <- ~X+Y
load("./data/eval.opt.2020-06-24.Rda")

gbifthin$suitability <-
  raster::extract(eval.opt@predictions, gbifthin)
samples$suitability <-
  raster::extract(eval.opt@predictions, samples)

rasterProj <- projectExtent(eval.opt@predictions, canlam)
res(rasterProj) <- 10000
predTR <- projectRaster(eval.opt@predictions, rasterProj)
predTR[predTR < quantile(getValues(predTR),
                         probs = 0.85, na.rm = TRUE)] <- NA

samples.proj <- spTransform(samples, canlam)
kernelProj <- projectRaster(kernelRaster, rasterProj)
kernelProj[kernelProj < 0.007] <- NA

```
## sPCA

```{R spca} 
nbd <- dnearneigh(trichGP4$other$xy, d1 = 1, d2 = 650,
                 longlat = TRUE)

invdist <- lapply(nbdists(nbd, trichGP4$other$xy), function(x) 1/x)
lw3 <- nb2listw(nbd, glist = invdist, style = "W")

trich.spca1 <- spca(trichGP4, cn = lw3, scannf=FALSE,
                   nfposi=4, nfnega=4)

X <- tab(trichGP4, freq = TRUE)
trich.pca <- ade4::dudi.pca(X, nf = 2, scannf = FALSE) 

  ## s.value(trich.spca1$xy, trich.spca1$li[, 1], include.origin = FALSE)
  ## plot(lw3, add = TRUE, coords = trich.spca1$xy)

grt <- global.rtest(trich.spca1$tab, lw3, k = 1, nperm = 4999)

myLoadings <- trich.spca1$c1[, 1]^2
names(myLoadings) <- rownames(trich.spca1$c1)
  ## loadingplot(myLoadings, xlab="Alleles",
  ##             ylab="Weight of the alleles",
  ##             main="Contribution of alleles\n to the first sPCA axis")

  ## temp <- loadingplot(myLoadings, threshold = quantile(myLoadings, 7/8),
  ##                    xlab = "Alleles", ylab = "Weight of the alleles",
  ##                    main =
  ##                      "Contribution of alleles\n to the first sPCA axis",
  ##                    fac = trichGP4$loc.fac, cex.fac = 0.6)
```


## Ordinations
```{R clone distances}
cloneDist <- dist(tab(tr97, freq = TRUE))
clonePCoA <- cmdscale(cloneDist,  eig = TRUE, k = 96)
## Numerically identical to a PCA on the same data:
## clonePCA <- dudi.pca(tab(tr97, freq = TRUE), nf = 63,
##                      scannf = FALSE, scale = FALSE)
eigVals <- round(100 * clonePCoA$eig/sum(clonePCoA$eig), 1)

myPops <- as.character(pop(tr97))
myPops[grep("^MO", myPops)] <- "MO"
myPops[grep("^MD", myPops)] <- "MD"
myPops[grep("^ON", myPops)] <- "ON"
myPops[grep("^KY", myPops)] <- "X"
myPops[grep("^OH", myPops)] <- "X"
myPops[grep("^NY", myPops)] <- "X"
myPops[grep("^NH", myPops)] <- "X"
myPops[grep("^MA", myPops)] <- "X"
myPops[grep("^CT", myPops)] <- "X"
myPops[grep("^NJ", myPops)] <- "X"
myPops[grep("^VA", myPops)] <- "X"
myPops[grep("^WV", myPops)] <- "X"
myPops[grep("^PA", myPops)] <- "X"
myPops <- as.factor(myPops)

myStates <- substr(as.character(pop(tr97)), 0, 2)
##myStates[myStates %in% c("MO", "MD", "ON")] <- NA
```
# Unused Code
Different things we tried that didn't end up generating anything
interesting enough to include in the manuscript.

```{R done}
message("Finished with good code!")
```

## Locus maps

```{R Locus TP330 map, fig.width = 7, fig.height = 5, dev = 'jpeg', fig.show = 'hold', dpi = 200, fig.caption = "*Trichophorum planifolium* Populations Sampled, color indicates frequency of allele TP330.356 in population.", eval = FALSE}
### dev.new(height = 5, width = 7)
par(mar = c(0.1,0.1,0.1,0.1))

plot(ca.proj, xlim = c(zm@xmin, zm@xmax),
     ylim = c(zm@ymin, zm@ymax), border = "grey",
     bg = "lightblue", col = "white")  
plot(us.proj, add = TRUE, border = "grey", col = "white")
plot(gl.proj, add = TRUE, border = "grey", col = "lightblue")
points(samples.proj, cex = 3, pch = 22, bg = grey(tab(trichGP4, freq = TRUE)[, c("TP330.356")]), col = "grey")
box()
```
## dapc

```{R dapc, eval = FALSE}

dapc97G <- find.clusters(tr97, max.n.clust = 40)
## 15 PCA, 10 clusters

table(pop(tr97), dapcGroups$grp)
table.value(table(pop(tr97), dapcGroups$grp))

dapc97 <- dapc(tr97, dapc97G$grp)
## 10 PCA, 3 DCA

dapc97G <- find.clusters(tr97, max.n.clust = 40)
## 15 PCA, 10 clusters

table(pop(tr97), dapcGroups$grp)
table.value(table(pop(tr97), dapcGroups$grp))

dapc97 <- dapc(tr97, dapc97G$grp)
## 10 PCA, 3 DCA

dapcComp <- find.clusters(trComp, max.n.clust = 40)
## 10 PCA, 30 clusters

tr2grps <- find.clusters(trichGI4, max.n.clust = 40, 
                         n.clust = 2, n.pca = 35)

tr5grps <- find.clusters(trichGI4, max.n.clust = 40, 
                         n.clust = 5, n.pca = 35)

tr10grps <- find.clusters(trichGI4, max.n.clust = 40,
                          n.clust = 10, n.pca = 35)

tr15grps <- find.clusters(trichGI4, max.n.clust = 40,
                          n.clust = 15, n.pca = 35)

tr2DAPC <- dapc(trichGI4, tr2grps$grp, n.pca = 35, n.da = 4)
tr5DAPC <- dapc(trichGI4, tr5grps$grp, n.pca = 35, n.da = 4)
tr10DAPC <- dapc(trichGI4, tr10grps$grp, n.pca = 35, n.da = 4)
tr15DAPC <- dapc(trichGI4, tr15grps$grp, n.pca = 35, n.da = 4)

assignPops <- function(DAPC){
  posterior <- predict(DAPC)$posterior
  posterior <- posterior[order(row.names(posterior)), ]
  pops <- substr(row.names(posterior), 0, 4)
  pops[grep("KY", row.names(posterior))] <- "KYLE"
  posterior <- cbind(population = pops, posterior)

  xlabels <- aggregate(1:nrow(posterior),
                       by = list(posterior[, "population"]),
                       FUN = mean)

  sampleEdges <- aggregate(1:nrow(posterior),
                           by = list(posterior[, "population"]), 
                           FUN = max)

  return(list(membership = posterior, populations = xlabels,
              edges = sampleEdges))
}

plotAssign <- function(x){
  barplot(t(as.matrix(x$membership[, -1])),
          col = rainbow(ncol(x$membership) - 1 ), 
          space = 0, xlab="Population", ylab = "Ancestry", 
          border = NA, axisnames = FALSE)
  abline(v = x$edges$x, lwd = 2)
  axis(1, at = x$populations$x - 0.5,
       labels = x$populations$Group.1, cex.axis = 0.5)
}

tr2assign <- assignPops(tr2DAPC)
plotAssign(tr2assign)

tr5assign <- assignPops(tr5DAPC)
plotAssign(tr5assign)

tr10assign <- assignPops(tr10DAPC) 
plotAssign(tr10assign)

quickDAPC <- function(x, n){
  grps <- find.clusters(x, max.n.clust = 40, 
                        n.clust = n, n.pca = 35)
  dapc <- dapc(x, grps$grp, n.pca = 35, n.da = 4)
  assign <- assignPops(dapc)
  plotAssign(assign)
}

quickDAPC(trichGI4, 7)

tr2grps <- find.clusters(trichGI4, max.n.clust = 40, 
                         n.clust = 2, n.pca = 35)
tr2DAPC <- dapc(trichGI4, tr2grps$grp, n.pca = 35, n.da = 4)
tr10assign <- assignPops(tr10DAPC) 
plotAssign(tr10assign)

```


## Bruvo.dist

```{R bruvo, eval = FALSE}
SSRLengths = c(TP142 = 3, TP152 = 2, TP174 = 3, TP325 = 3,
               TP326 = 2, TP330 = 3, TP341 = 3, TP406 = 3,
               TP434 = 3, TP45 = 3, TP80B = 3) 
bdist <- bruvo.dist(trichGI4, SSRLengths)
b97dist <- bruvo.dist(tr97, SSRLengths)

bclust <- hclust(b97dist, method = "average")
plot(bclust, labels = pop(tr97))

fixPops <- factor(pop(tr97),
                        levels =
                          c("MOBS", "MOBU", "MOHC", "MOOC", "MOSH",
                            "OHBH", "OHHH", "OHPR", "OHSC", "KY",
                            "CTTP", "MABM", "MAMT", "MAST", "NHER",
                            "NJKP", "NYMP", "NYTS", "ONRB",
                            "PABE", "PACR", "PAGP", "PASG",
                            "VAAC", "VAHB", "VASC", "WVFM",
                            "WVMO", "WVSS", "MDDM"))

tr97@pop <- fixPops

tr97.msn <- bruvo.msn(tr97, SSRLengths,
                      vertex.label = NA,
                      palette = rainbow)


bdPCoA <- cmdscale(bdist, k = 504, eig = TRUE)
bStates <- substr(pop(trichGI4), 0, 2)

bdPops <- as.character(pop(trichGI4))
bdPops[grep("^MO", bdPops)] <- "MO"
bdPops[grep("^MD", bdPops)] <- "MD"
bdPops[grep("^ON", bdPops)] <- "ON"
bdPops[grep("^KY", bdPops)] <- "X"
bdPops[grep("^OH", bdPops)] <- "X"
bdPops[grep("^NY", bdPops)] <- "X"
bdPops[grep("^NH", bdPops)] <- "X"
bdPops[grep("^MA", bdPops)] <- "X"
bdPops[grep("^CT", bdPops)] <- "X"
bdPops[grep("^NJ", bdPops)] <- "X"
bdPops[grep("^VA", bdPops)] <- "X"
bdPops[grep("^WV", bdPops)] <- "X"
bdPops[grep("^PA", bdPops)] <- "X"
bdPops <- as.factor(bdPops)

plot(scores(bdPCoA)[, c(1,2)], type = 'n',
     asp = 1, axes = FALSE, xlab = NA, ylab = NA)
statesbrSpider <- unique(unclass(ordispider(bdPCoA, groups = bStates,
                                         col = "grey")))
points(scores(bdPCoA)[, c(1,2)], asp = 1, pch = 16)
text(statesbrSpider, cex = 1,
     labels = substr(row.names(statesbrSpider), 0, 2))

points(scores(bdPCoA)[, c(1,2)], pch = c(21:24)[bdPops],
     asp = 1, bg = c(2:4, "grey")[bdPops],
     col = c(1, 1, 1, 0)[bdPops],
     cex = c(1.5, 1.5, 1.5, 1)[bdPops])
```

## Allele sizes
```{R allele-sizes, eval = FALSE}
fixPops <- factor(pop(trichGI4),
                        levels =
                          c("MOBS", "MOBU", "MOHC", "MOOC", "MOSH",
                            "OHBH", "OHHH", "OHPR", "OHSC", "KY",
                            "CTTP", "MABM", "MAMT", "MAST", "NHER",
                            "NJKP", "NYMP", "NYTS", "ONRB",
                            "PABE", "PACR", "PAGP", "PASG",
                            "VAAC", "VAHB", "VASC", "WVFM",
                            "WVMO", "WVSS", "MDDM"))

trichGI4@pop <- fixPops

MyColorFun <- function(n){
  case_when(
    n < 6 ~ 'red',
    n < 11 ~ 'orange',
    n < 16 ~ 'yellow',
    n < 21 ~ 'green',
    n < 26 ~ 'blue',
    n < 31 ~ 'violet',
    n > 30 ~ 'black')
}

myCols <- rep(c("red", "orange", "yellow", "black", "green",
                "blue", "violet"), times = c(5, 4, 1, 5, 5,
                                             5, 5)) 

trich.msn <- bruvo.msn(trichGI4, SSRLengths,
                       palette = myCols,
                       vertex.label = NA)


tmp <- new("bruvomat", trichGI4, SSRLengths)
tmpPops <- pop(trichGI4)

locFac(trichGI4)
trichGI4[, loci = "TP142"]
locN
lociNames <- levels(locFac(trichGI4))

tab(trichGI4[, loc = lociNames[1]])

```


## Peripheral Population Regressions

```{R index plots, fig.width=7.25, fig.height = 3.5, eval = FALSE}
#dev.new(width = 7.25, height = 3.5)
par(mfrow = c(1, 3), mar = c(5, 4, 2, 1))
lmdf <- 

imlm <- lm(log(gbifthin$isolation) ~ log(gbifthin$marginality))
islm <- lm(log(gbifthin$isolation) ~ log(gbifthin$suitability))
smlm <- lm(log(gbifthin$suitability) ~ log(gbifthin$marginality))

plot(log(gbifthin$isolation) ~ log(gbifthin$marginality),
     xlab = "Peripherality", ylab = "Isolation",
     pch = 16, col = alpha(1, 0.3), cex = 1.5)
abline(imlm)

plot(log(gbifthin$isolation) ~ log(gbifthin$suitability),
     xlab = "Suitability", ylab = "Isolation",
     pch = 16, col = alpha(1, 0.3), cex = 1.5)
abline(islm)

plot(log(gbifthin$suitability) ~ log(gbifthin$marginality),
     xlab = "Marginality", ylab = "Suitability",
     pch = 16, col = alpha(1, 0.3), cex = 1.5)
abline(smlm)
```

```{R regression plots, eval = FALSE}
samples@data %>% ggplot() +
  aes(x = log(isolation), y = emlg) +
  geom_point(size = 3) + geom_smooth(method = "lm") +
  ggtitle("eMLG ~ Isolation")

summary(lm(emlg ~ log(isolation), data = samples@data))

samples@data %>% ggplot() +
  aes(x = log(marginality), y = emlg) +
  geom_point(size = 3) + geom_smooth(method = "lm") +
  ggtitle("eMLG ~ Marginality")

summary(lm(emlg ~ log(marginality), data = samples@data))

samples@data %>% ggplot() +
  aes(x = log(suitability), y = emlg) +
  geom_point(size = 3) + geom_smooth(method = "lm") +
  ggtitle("eMLG ~ Suitability")

summary(lm(emlg ~ log(suitability), data = samples@data))

samples@data %>% ggplot() +
  aes(x = log(isolation), y = meanFst) +
  geom_point(size = 3) + geom_smooth(method = "lm") +
  ggtitle("meanFst ~ Isolation")

summary(lm(meanFst ~ log(isolation), data = samples@data))

samples@data %>% ggplot() +
  aes(x = log(marginality), y = meanFst) +
  geom_point(size = 3) + geom_smooth(method = "lm") +
  ggtitle("meanFst ~ Marginality")

summary(lm(meanFst ~ log(marginality), data = samples@data))

samples@data %>% ggplot() +
  aes(x = log(suitability), y = meanFst) +
  geom_point(size = 3) + geom_smooth(method = "lm") +
  ggtitle("meanFst ~ Suitability")

summary(lm(meanFst ~ log(suitability), data = samples@data))

gbifthin@data %>% ggplot() +
  aes(x = log(suitability), y = log(marginality)) +
  geom_point(size = 3) + geom_smooth(method = "lm") +
  ggtitle("Marginality ~ Suitability")

gbifthin@data %>% ggplot() +
  aes(x = log(suitability), y = log(isolation)) +
  geom_point(size = 3) + geom_smooth(method = "lm") +
  ggtitle("Isolation ~ Suitability")

```

## STRUCTURE
We did try STRUCTURE, INSTRUCT, GESTE. Nothing came of it.

### Exporting to Structure

```{R exportStructure, eval = FALSE}
trichGI4df <- genind2df(trichGI4)
trichGI4df[is.na(trichGI4df)] <- -999
trichGI4hf <- genind2hierfstat(trichGI4)
write.struct(trichGI4hf, fname = "trichGI4.structure",
             ilab = row.names(trichGI4hf), pop = TRUE,
             MARKERNAMES = TRUE)
```

### Exporting to GESTE

```{R geste-export, eval = FALSE}
geste <- seppop(trichGI4)
geste <- lapply(geste, seploc)

geste.input <- file("geste.alleles", "w")

cat("[loci]=", length(geste[[1]]), "\n\n", file = geste.input)

cat("[populations]=", length(geste), "\n\n", file = geste.input)

for(popI in seq_along(geste)) {
  cat("[pop]=", popI, "\n", file = geste.input)
  for(locI in seq_along(geste[[popI]])){
    popLocus <- colSums(tab(geste[[popI]][[locI]]), na.rm = TRUE)
    popLocus <- c(locI, sum(popLocus, na.rm = TRUE), length(popLocus),
                 popLocus)
    cat(popLocus, "\n", file = geste.input)
  }
  cat("\n", file = geste.input)
}
  
close(geste.input)

write.table(file = "factors.txt",
            t(data.frame(samples[, c("marginality", "isolation")])),
            col.names = FALSE)

```

### Structure Analysis

``` bash
InStruct -d trichGI4.structure -o instruct.out -ik 1 -kv 1 30 \
         -v 2 -N 505 -L 11 -lb 1 -a 1 -w 1 -x 0 -af 0 -mm 8.0e9 
```

reviewing the Deviance values:
``` bash
grep -a Deviance instruct.out
```

Grabbing the best:
``` bash
awk '/K is 16/,/K is 17/' instruct.out > k16.out
awk '/Chain#1/,/Chain#2/' k16.out > k16-1.out
awk '/^Indv\tLabel/,/^$/' k16-1.out > k16.q
```

```{R loadInstruct, eval = FALSE}
instruct <- read.table("data/k16.q", header = TRUE, sep = "\t")
instruct <- read.table("data/k10.q", header = TRUE, sep = "\t")
colnames(instruct) <- gsub("\\.+$", "", colnames(instruct))
colnames(instruct) <- gsub("^X\\.", "", colnames(instruct))
rownames(instruct) <- NULL
instruct$Miss <- gsub("[()]", "", instruct$Miss)
instruct$Pop <- substr(instruct$Label, 0, 4)
instruct$Pop[grep("KY", instruct$Pop)] <- "KYLE"
instruct <- instruct[order(instruct$Label), ]

insertPopBefore <- function(x, pop, before){
  whichPop <- which(x$Pop == pop)
  popRows <- x[whichPop, ]
  res <- x[-whichPop, ]
  insertBefore <- min(which(res$Pop == before))
  resBefore <- res[1:(insertBefore -1), ]
  resAfter <- res[insertBefore:nrow(res), ]
  res <- rbind(resBefore, popRows, resAfter)
  return(res)
}

## K= 16 reordering:
instruct <- insertPopBefore(instruct, "CTTP", "NYMP")
instruct <- insertPopBefore(instruct, "MOBS", "MOOC")
instruct <- insertPopBefore(instruct, "MDDM", "NJKP")
instruct <- insertPopBefore(instruct, "MABM", "MAST")
instruct <- insertPopBefore(instruct, "OHHH", "OHSC")
instruct <- insertPopBefore(instruct, "WVFM", "OHBH")
instruct <- insertPopBefore(instruct, "MAMT", "ONRB")
instruct <- insertPopBefore(instruct, "PACR", "PASG")
instruct <- insertPopBefore(instruct, "WVMO", "WVFM")
instruct <- insertPopBefore(instruct, "VAHB", "PAGP")
instruct <- insertPopBefore(instruct, "KYLE", "OHHH")
instruct <- insertPopBefore(instruct, "ONRB", "MDDM")

## K = 10 reordering
instruct <- insertPopBefore(instruct, "MAMT", "KYLE")
instruct <- insertPopBefore(instruct, "NYMP", "KYLE")
instruct <- insertPopBefore(instruct, "WVSS", "KYLE")
instruct <- insertPopBefore(instruct, "VAAC", "MDDM")
instruct <- insertPopBefore(instruct, "MOOC", "MOBU")
instruct <- insertPopBefore(instruct, "MOSH", "MOBU")
instruct <- insertPopBefore(instruct, "OHSC", "NHER")
barplot(as.matrix(t(instruct[, -1:-4])), border = "NA",
        col = rainbow(10), legend.text = 1:10, space = 0,
        names.arg = rep("", nrow(instruct)),
        #density = c(60, NA), angle = c(45, 45, -45, -45)
        )
xlabels <- aggregate(1:nrow(instruct), by = list(instruct$Pop), FUN = mean)
axis(1, at = xlabels$x - 0.5, labels = xlabels$Group.1,
     cex.axis = 0.5)
sampleEdges <- aggregate(1:nrow(instruct), by = list(instruct$Pop), FUN = max)
abline(v = sampleEdges$x, lwd = 2)


structPlot <- 
instruct %>% group_by(Pop) %>%
pivot_longer(names_to = "cluster", values_to = "proportion",
             cols = Cluster.1:Cluster.10) %>%
ggplot() + geom_col(aes(x = Label, y = proportion,
                        col = cluster, fill = cluster), width = 1) + facet_wrap(~Pop)

```
